# OSSW_20231709
OSSW-HW02-README-20231709

마크다운 기능 활용과 리눅스 명령어 조사.

*작성일: 2025-11-20*

***

## 목차
1. 명령어 설명
    1) top
       - 기본 설명과 형식
       - 옵션
       - 예제
    3) ps
    4) jobs
    5) kill   
2. 명령어 요약 표
3. 실전 연습 문제 (SadServers)

***

## 1. 명령어 설명

### 1) top - 실시간 시스템 모니터링
**1.**  
현재 시스템의 CPU, 메모리 사용량과 실행 중인 프로세스들의 상태를 **실시간**으로 갱신하며 보여주는 도구이다. 윈도우의 작업 관리자와 유사한 역할을 하며, 서버의 부하 상태를 진단할 때 가장 먼저 사용된다.

*   **형식**: `top [옵션]`

**2. 옵션**

| 옵션/키 | 설명 |
| :--- | :--- |
| `top -u [user]` | 특정 사용자의 프로세스만 모니터링한다. |
| `top -d [sec]` | 화면 갱신 주기를 초 단위로 설정한다. (기본 3초) |
| `Shift + P` | CPU 사용률 순으로 정렬한다. (실행 중 입력) |
| `Shift + M` | 메모리 사용률 순으로 정렬한다. (실행 중 입력) |
| `k` | 프로세스를 종료(Kill)할 수 있는 프롬프트를 띄운다. |
| `c` | 명령어의 전체 경로(Full Path)를 표시하거나 숨긴다. |

**3. 예제**
```bash
# 사용자 'student'의 프로세스만 1초 간격으로 확인
$ top -u student -d 1
```
*(실행 결과 예시)*
```
top - 15:30:01 up 10 days,  2:30,  1 user,  load average: 0.05, 0.03, 0.00
Tasks: 102 total,   1 running, 101 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.2 us,  0.5 sy,  0.0 ni, 98.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8000000 total,  4000000 free,  2000000 used,  2000000 buff/cache
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 1234 student   20   0   10000   5000   2000 S   0.5  0.1   0:01.50 python3
```

***

### 2) ps - 프로세스 스냅샷 확인
**1.**
현재 실행 중인 프로세스들의 상태를 **정적(Static)**인 스냅샷으로 출력한다. `top`과 달리 특정 시점의 상태를 기록하거나, `grep`과 조합하여 특정 프로세스를 검색할 때 주로 사용된다.

*   **형식**: `ps [옵션]`

**2. 옵션**

| 옵션 | 설명 |
| :--- | :--- |
| `-e` 또는 `-A` | 시스템의 모든 프로세스를 출력한다. |
| `-f` | 풀 포맷(Full-format)으로 출력한다. (UID, PID, PPID 등 포함) |
| `aux` | BSD 스타일 옵션. 모든 사용자(`a`), 터미널 없는 프로세스 포함(`x`), 사용자 중심 출력(`u`)을 의미한다. |
| `-u [user]` | 특정 사용자의 프로세스만 출력한다. |

**3. 예제**
```bash
# python 프로세스 찾기 (BSD 스타일)
$ ps aux | grep python
```
*(실행 결과 예시)*
```
root      1234  0.0  0.1  50000  2000 ?        Ss   10:00   0:00 /usr/bin/python3 system_daemon.py
student   5678  1.5  2.3 120000 40000 pts/0    S+   13:00   0:05 python3 my_script.py
```

***

### 3) jobs - 작업(Job) 제어
**1.**
현재 셸(Shell) 세션 내에서 실행된 작업들의 목록을 확인하고 상태를 제어한다. 백그라운드(`&`)로 실행된 작업이나 중지된(`Ctrl+Z`) 작업을 관리할 때 사용되는 **셸 내부 명령어(Built-in)**이다.

*   **형식**: `jobs [옵션]`

**2. 옵션**

| 옵션/명령 | 설명 |
| :--- | :--- |
| `-l` | 작업 번호와 함께 프로세스 ID(PID)도 출력한다. |
| `&` | 명령어 뒤에 붙여 백그라운드로 실행한다. |
| `fg %[번호]` | 백그라운드/중지된 작업을 포그라운드(Foreground)로 가져온다. |
| `bg %[번호]` | 중지된 작업을 백그라운드에서 계속 실행(Running)되게 한다. |

**3. 예제**
```bash
# 1. 오래 걸리는 작업 백그라운드 실행
$ sleep 500 &
[1] 10500

# 2. 작업 목록 확인
$ jobs
```
*(실행 결과 예시)*
```
[1]+  Running                 sleep 500 &
```

***

### 4) kill - 프로세스 시그널 전송
**1.**
지정된 프로세스(PID)나 작업(%Job번호)에 **시그널(Signal)**을 보낸다. 이름은 'kill'이지만 종료 외에도 다양한 제어 신호를 보낼 수 있다.

*   **형식**: `kill [옵션/시그널] [PID 또는 %작업번호]`

**2. 옵션**

| 옵션/시그널 | 번호 | 설명 |
| :--- | :--- | :--- |
| `-l` | | 사용 가능한 모든 시그널 목록을 출력한다. |
| `-15` (SIGTERM) | 15 | **정상 종료**. 프로세스에게 종료를 요청하며, 정리할 시간을 준다. (기본값) |
| `-9` (SIGKILL) | 9 | **강제 종료**. 프로세스를 즉시 메모리에서 제거한다. 데이터 유실 위험이 있다. |
| `-2` (SIGINT) | 2 | 키보드 인터럽트. `Ctrl+C`와 동일한 효과를 낸다. |

**3. 예제**
```bash
# PID 1234 프로세스 정상 종료 요청
$ kill 1234

# 응답 없는 PID 1234 강제 종료
$ kill -9 1234
```
> **주의:** `kill -9`는 최후의 수단으로 사용해야 한다.

***

## 2. 표 (명령어 한 눈에 보기)

| 명령어 | 핵심 역할 | 특징 | 주요 사용 사례 |
| :---: | :--- | :--- | :--- |
| **top** | **실시간** 모니터링 | 자동 갱신, 자원 점유율 정렬 가능 | 서버가 느려졌을 때 CPU/메모리 범인 찾기 |
| **ps** | **정적** 스냅샷 확인 | 옵션 조합이 다양함, 파이프라인 연동 | 특정 프로세스(PID) 검색, 스크립트 작성 |
| **jobs** | **작업(Job)** 제어 | 셸 내부 명령어, 백그라운드 관리 | 실행 중인 작업을 잠깐 멈추거나 배경으로 보낼 때 |
| **kill** | **시그널** 전송 | PID 필요, 정상/강제 종료 구분 | 응답 없는 프로그램 종료, 서비스 재시작 신호 |

***

## 3. 실전 연습 문제 (SadServers)
각 명령어를 실제 서버 환경에서 연습해볼 수 있는 SadServers 시나리오이다.

### 1) top & kill 실습

**1. 문제 제목**  
"Saint John": what is writing to this log file?

**2. 링크**  
SadServers - Saint John 시나리오

**3. 문제 설명**  
어떤 프로세스가 /var/log/bad.log 파일에 끊임없이 로그를 쓰고 있어서 디스크가 가득 차는 상황이다. top 등으로 시스템 상황을 파악하고, 범인 프로세스를 찾아 kill 명령어로 종료시켜야 한다.

**4. 해결 방법 (Solution)**  

top 명령어를 입력해 현재 CPU를 많이 쓰는 프로세스가 있는지 확인한다 (보통 상단에 badlog.py 같은 이름이 뜬다).

또는 lsof /var/log/bad.log 명령어로 해당 파일을 잡고 있는 프로세스의 PID를 찾는다.

찾아낸 PID를 kill [PID] 명령어로 종료시킨다.

```
bash
$ top
$ lsof /var/log/bad.log
COMMAND   PID USER ...
python3   621 admin ...
$ kill 621
```

### 2) ps & jobs 실습

**1. 문제 제목**
"Melboune": wsgi with gunicorn

**2. 링크**
SadServers - Melbourne 시나리오

**3. 문제 설명**
파이썬 웹 서버(Gunicorn)가 자꾸 죽거나 응답하지 않는 상황이다. 서버를 실행할 때 터미널을 차지하지 않게 **백그라운드(&)**로 실행하거나, 서비스(systemd)로 등록하여 관리하는 개념을 익힐 수 있다. 문제 해결 과정에서 ps를 통해 포트 충돌을 확인하는 단계가 포함된다.

**4. 해결 방법 (Solution)**
Gunicorn 서버를 올바르게 실행하고 포트 충돌을 해결하는 과정이다.
```
bash
# 이미 80번 포트를 쓰고 있는 프로세스 확인 (ps, lsof)
$ ps aux | grep gunicorn
# 또는
$ netstat -nlp | grep 80

# 기존 프로세스 kill 후, 백그라운드로 다시 실행
$ gunicorn app:app -b 0.0.0.0:80 &
$ jobs  # 백그라운드 실행 확인
```
